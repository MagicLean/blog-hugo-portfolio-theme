---
title: 浅谈消息队列
date: 2022-08-07T10:59:47.753Z
draft: false
featured: false
tags:
  - Java
  - 消息队列
categories:
  - Java
image:
  filename: blob:https://pengli.netlify.app/7fb006a9-02ff-4f67-97b6-9e90ac751a63
  focal_point: SMART
  preview_only: false
---


## 一、什么是消息队列

![消息队列](blob:https://pengli.netlify.app/7fb006a9-02ff-4f67-97b6-9e90ac751a63)

定义：消息队列是一种异步的服务间通信方式。

简单来讲：消息队列（message queue）就如词组的两个部分：消息+队列，即将要处理的消息（数据）存储在相应的队列中。

消息（message）是指在分布式下各种应用服务之间传送的数据，可以非常简单（只包含少量文本字符串），也可以非常复杂（嵌套对象等）；而队列（queue）就是符合FIFO（先进先出）的线性存储结构。

注：使用消息队列时，消息的生产者和消费者不一定同时与消息队列交互，消息会保存在队列中，直到消费者取回它。

## 二、消息模型

讲完消息队列的大致概念后，就不得不提到其使用到的两种消息模型了。

目前消息队列有很多种，如Kafaka、RocketMq、RabbitMq，所有消息队列的模型都比较类似，基本都包括像队列（Queue）、主题（Topic）这两个概念，分别也对应着点对点和发布-订阅两种模型。

### 点对点模型（Queue）

![点对点模型](blob:https://pengli.netlify.app/e8dc5bf6-63c4-414d-a30c-2b1903c1c76f)

在点对点模型中，消息生产者将消息发送到由某个名字标识的特定消费者，消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。

**特点：**

1. 每个消息只有一个消费者；
2. 发送者和接受者没有时间依赖；
3. 接受者确认消息接受和处理是否成功。

### 发布/订阅模型（Pub/Sub）

![发布/订阅模型](blob:https://pengli.netlify.app/a9e4be50-eeff-43f8-a611-8b6effb571ad)

* 在发布者/订阅者模型中，包含三个角色：主题（Topic），发布者（Publisher），订阅者（Subscriber） 。
* 多个发布者将消息发送到Topic，系统将这些消息传递给多个订阅者。
* 发布者需要向一个特定的 消息主题（Topic） 生产消息。
* `0` 或 多个订阅者可能对接收来自特定消息主题的消息感兴趣。
* 发布者和订阅者彼此不知道对方，只有订阅了特定主题的订阅者才会收到消息。

特点：

* 每个消息可以有多个消费者
* 发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息。
* 为了消费消息，订阅者必须保持运行的状态。

注：发布与订阅模式和观察者模式很类似，都涉及到订阅式通信，但也有所不同：

* 观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过消息代理（message broker）进行通信。
* 观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向消息代理发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。

## 三、数据交互模式

### 推模式（Push）

推模式指的是消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息的发送。

推模式的实现是客户端会与服务端（Broker）建立长连接，当有消息时服务端会通过长连接通道将消息推送给客户端，这样客户端就能实时消费到最新的消息。

优点：

* 实时性强，有消息立马推送给客户端。
* 客户端实现简单，只需要监听服务端的推送即可。

缺点：

* 容易导致客户端发生消息堆积的情况，因为每个客户端的消费能力是不同的，如果简单粗暴的有消息就推送，就可能出现堆积情况。
* 没有信息状态跟踪。Push模式采用开环控制技术，一个信息推送后的状态，比如客户端是否接收等，无从得知。

因此，推模式难以根据消费者的状态控制推送速率，适用于消息量不大、消费能力强要求实时性高的情况下。

### 拉模式（Pull）

拉模式指的是 Consumer 主动向 Broker 请求拉取消息，即 Broker 被动的发送消息给 Consumer。

拉模式通常是基于长轮询来实现，结合了传统的推和拉模式的实现，因此，RocketMQ、Kafka等主流消息队列默认是拉模式。

长轮询就是客户端发起定时轮训请求，会保持请求到服务端，直到设置的超时时长(该hold时长要小于HTTP超时时间)到期或者服务端收到消息时进行返回数据。consumer收到响应后根据状态判断是否有新消息。

优点：

* 消费者可以根据自身的情况来发起拉取消息的请求，不会造成客户端消息积压，消费完了再去拉取，主动权在自己手中。

缺点：

* 消息延迟：因为消费者需要不断地拉取，但是又不能过于频繁地请求，因此需要降低请求的频率，那么消息会有一定的延时。
* 消息忙请求：消息超时时间设置短，则轮询频率过快导致服务端会承担压力，甚至导致空转，浪费资源。

## 四、消息队列的使用场景

### 异步处理

发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。

例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中，用户可以在注册完成后再进行验证。

### 流量削锋

在高并发的场景下，如果短时间有大量的请求同时发起，很大概率会压垮服务器。

使用消息队列能够使关键组件顶住突发的访问压力，可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理，而不会因为突发的超负荷的请求而完全崩溃。

### 应用解耦

如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。

通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。系统之间不是 **强耦合的**，**消息接受者** 可以随意增加，而不需要修改 **消息发送者的代码**。**消息发送者** 的成功不依赖 **消息接受者**。并且对于一些 **非核心流程**，也可以放到消息队列中让 **消息消费者** 去按需消费，而 **不影响核心主流程**。

注：使用消息队列，可以在一定程度保障系统的可恢复性。消息队列降低了进程间的耦合度，当系统的一部分组件失效时，不会影响到整个系统，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。

### 日志处理

将消息队列用在 日志处理 中，比如 Kafka的应用，可有效解决海量日志传输和缓冲的问题。

目前比较常用的日志处理过程为：

![日志处理流程](blob:https://pengli.netlify.app/7ae434d9-4b8c-4679-b09f-f03231556c1b)

* 日志采集客户端，负责日志数据采集，写入Kafka队列（如Fluent Bit）
* Kafka消息队列，负责日志数据的接收，存储和转发
* 日志处理应用：订阅并消费Kafka队列中的日志数据（如Logstash）

## 五、常用的消息中间件比较

|  -     | RabbitMQ                                     | ActiveMQ                    | RocketMQ        | Kafka                         |
| ------ | -------------------------------------------- | --------------------------- | --------------- | ------------------------------ |
| 所属公司   | Mozilla                                      | Apache                      | Ali             | Apache                         |
| 成熟度    | 成熟                                           | 成熟                          | 比较成熟            | 成熟                             |
| 授权方式   | 开源                                           | 开源                          | 开源              | 开源                             |
| 开发语言   | Erlang                                       | Java                        | Java            | Scala & Java                   |
| 支持语言   | 官方支持Erlang，Java，Ruby等；社区产出多种语言api，几乎支持所有常用语言 | Java，C，C++，Python，PHP，Perl等 | Java，C++（不成熟）   | 官方支持Java；开源社区支持多语言，如Python，Go等 |
| 消息推拉模式 | 多协议，pull/push均可                              | 多协议，pull/push均可             | 多协议，pull/push均可 | 仅pull                          |
| 单机吞吐量  | 万级                                           | 万级                          | 10万级，高吞吐        | 10万级，高吞吐                       |
| 时效性    | 微秒级，延迟最低                                     | ms级                         | ms级             | ms级                            |

## 六、扩展

### RocketMQ简介

[RocketMQ](https://github.com/alibaba/RocketMQ)出自 阿里公司的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，消息可靠性上比 Kafka 更好。RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。

主要特性：

1. 是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式特点；
2. Producer、Consumer、队列都可以分布式；
3. Producer向一些队列轮流发送消息，队列集合称为Topic，Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列，如果做集群消费，则多个Consumer实例平均消费这个topic对应的队列集合；
4. 能够保证严格的消息顺序；
5. 提供丰富的消息拉取模式；
6. 高效的订阅者水平扩展能力；
7. 实时的消息订阅机制；
8. 亿级消息堆积能力；
9. 较少的依赖；

### 消息代理(Message Broker)

消息代理是消息传递中间件或面向消息的中间件 (Message-oriented middleware) 解决方案中的软件模块，用于消息验证、变换、路由。消息队列是消息代理的子结构或组件。虽然不同的消息中间件架构和实现各不相同，但是大部分都实现了Broker：即消息中间件服务器，它是中间件的核心。

注：RabbitMQ、Kafka、RocketMQ等都有消息代理，但不是所有中间件都会这么设计，例如ZeroMQ就使用了套接字风格的API。

## 参考资料

* [Observer vs Pub-Sub](http://developers-club.com/posts/270339/)
* [观察者模式](https://refactoringguru.cn/design-patterns/observer)
* [消息队列中点对点与发布订阅区别](https://blog.csdn.net/lizhitao/article/details/47723105)
* [浅谈消息队列及常见的消息中间件](https://juejin.cn/post/6844903635046924296)
* [消息队列及常见消息队列介绍](https://cloud.tencent.com/developer/article/1006035)
* [RocketMQ系列4-长轮询模式实现推送消息](https://www.jianshu.com/p/70800fe967fd)